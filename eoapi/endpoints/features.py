from typing import Any

from fastapi import APIRouter, Query, Request

from pygeoapi.api import FORMAT_TYPES, F_JSON
from pygeoapi.util import url_join

from eoapi.dhis2_integration import fetch_org_units_from_dhis2
from eoapi.endpoints.constants import CRS84
from eoapi.endpoints.errors import invalid_parameter, not_found
from eoapi.jobs import get_job

router = APIRouter(tags=["Features"])


ORG_UNIT_FEATURES: list[dict[str, Any]] = [
    {
        "type": "Feature",
        "id": "O6uvpzGd5pu",
        "geometry": {
            "type": "Polygon",
            "coordinates": [[[ -11.64, 8.42], [-11.50, 8.42], [-11.50, 8.55], [-11.64, 8.55], [-11.64, 8.42]]],
        },
        "properties": {"name": "Bo", "level": 2},
    },
    {
        "type": "Feature",
        "id": "fdc6uOvgoji",
        "geometry": {
            "type": "Polygon",
            "coordinates": [[[-13.30, 8.80], [-13.10, 8.80], [-13.10, 9.00], [-13.30, 9.00], [-13.30, 8.80]]],
        },
        "properties": {"name": "Bombali", "level": 2},
    },
    {
        "type": "Feature",
        "id": "lc3eMKXaEfw",
        "geometry": {
            "type": "Polygon",
            "coordinates": [[[-12.40, 7.00], [-12.10, 7.00], [-12.10, 7.25], [-12.40, 7.25], [-12.40, 7.00]]],
        },
        "properties": {"name": "Bonthe", "level": 2},
    },
]


def _base_url(request: Request) -> str:
    return str(request.base_url).rstrip("/")


def _parse_bbox(bbox: str | None) -> tuple[float, float, float, float] | None:
    if bbox is None:
        return None

    try:
        values = tuple(float(part.strip()) for part in bbox.split(","))
    except ValueError as exc:
        raise invalid_parameter("bbox must contain 4 comma-separated numbers") from exc

    if len(values) != 4:
        raise invalid_parameter("bbox must contain 4 comma-separated numbers")

    minx, miny, maxx, maxy = values
    if minx >= maxx or miny >= maxy:
        raise invalid_parameter("bbox must follow minx,miny,maxx,maxy with min < max")

    return values


def _feature_bbox(feature: dict[str, Any]) -> tuple[float, float, float, float]:
    ring = feature["geometry"]["coordinates"][0]
    xs = [point[0] for point in ring]
    ys = [point[1] for point in ring]
    return (min(xs), min(ys), max(xs), max(ys))


def _intersects(a: tuple[float, float, float, float], b: tuple[float, float, float, float]) -> bool:
    return not (a[2] < b[0] or a[0] > b[2] or a[3] < b[1] or a[1] > b[3])


def org_unit_items(level: int = 2, bbox: tuple[float, float, float, float] | None = None) -> list[dict[str, Any]]:
    dhis2_features = fetch_org_units_from_dhis2(level)
    features = dhis2_features or [feature for feature in ORG_UNIT_FEATURES if feature["properties"].get("level") == level]
    if bbox is not None:
        features = [feature for feature in features if _intersects(_feature_bbox(feature), bbox)]
    return features


@router.get("/features")
def get_feature_collections(request: Request) -> dict[str, Any]:
    base = _base_url(request)
    features_url = url_join(base, "features")
    return {
        "collections": [
            {
                "id": "dhis2-org-units",
                "title": "DHIS2 organisation units",
                "description": "Organisation unit features from DHIS2-compatible structure.",
                "itemType": "feature",
                "crs": [CRS84],
                "links": [
                    {
                        "rel": "items",
                        "type": FORMAT_TYPES[F_JSON],
                        "title": "Feature items",
                        "href": url_join(base, "features", "dhis2-org-units", "items"),
                    }
                ],
            },
            {
                "id": "aggregated-results",
                "title": "Aggregated process results",
                "description": "Feature collection generated by process executions.",
                "itemType": "feature",
                "crs": [CRS84],
                "links": [
                    {
                        "rel": "items",
                        "type": FORMAT_TYPES[F_JSON],
                        "title": "Feature items",
                        "href": url_join(base, "features", "aggregated-results", "items"),
                    }
                ],
            },
        ],
        "links": [
            {"rel": "self", "type": FORMAT_TYPES[F_JSON], "href": features_url},
            {"rel": "root", "type": FORMAT_TYPES[F_JSON], "href": url_join(base, "/")},
        ],
    }


@router.get("/features/{collectionId}/items")
def get_feature_items(
    collectionId: str,
    request: Request,
    level: int = Query(default=2, ge=1),
    bbox: str | None = None,
    jobId: str | None = None,
) -> dict[str, Any]:
    base = _base_url(request)
    items_url = url_join(base, "features", collectionId, "items")

    if collectionId == "dhis2-org-units":
        bbox_values = _parse_bbox(bbox)
        features = org_unit_items(level=level, bbox=bbox_values)
    elif collectionId == "aggregated-results":
        if not jobId:
            raise invalid_parameter("jobId is required for aggregated-results")
        job = get_job(jobId)
        if job is None:
            raise not_found("Job", jobId)
        features = job["outputs"].get("features", [])
    else:
        raise not_found("Feature collection", collectionId)

    return {
        "type": "FeatureCollection",
        "timeStamp": jobId or "current",
        "numberMatched": len(features),
        "numberReturned": len(features),
        "features": features,
        "links": [
            {"rel": "self", "type": FORMAT_TYPES[F_JSON], "href": items_url},
            {"rel": "collection", "type": FORMAT_TYPES[F_JSON], "href": url_join(base, "features")},
            {"rel": "root", "type": FORMAT_TYPES[F_JSON], "href": url_join(base, "/")},
        ],
    }
